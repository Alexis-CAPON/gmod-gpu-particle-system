#version 430 core

// ============================================================================
// Particle Update Compute Shader
// Updates all particles in parallel on the GPU
// Thread group size: 64 particles per group
// ============================================================================

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// ============================================================================
// Particle Structure (matches CPU-side structure)
// ============================================================================

struct Particle {
    vec3 position;
    vec3 velocity;
    vec3 startPosition;
    float lifetime;
    float age;
    float size;
    float startSize;
    vec3 rotation;
    float rotationSpeed;
    vec4 color;
    vec4 startColor;
    float randomSeed;
    int alive;
    int _padding[3];  // Alignment padding
};

// ============================================================================
// Shader Storage Buffers
// ============================================================================

layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

layout(std430, binding = 1) buffer AliveIndexBuffer {
    uint aliveIndices[];
};

layout(std430, binding = 2) buffer AliveCountBuffer {
    uint aliveCount;
    uint _padding[3];
};

// ============================================================================
// Uniforms
// ============================================================================

uniform float uDeltaTime;
uniform vec3 uGravity;
uniform float uDrag;
uniform float uSimulationSpeed;

// Size over lifetime (1D texture sampled by normalized age)
uniform sampler1D uSizeOverLifetimeCurve;
uniform bool uSizeOverLifetimeEnabled;

// Color over lifetime (1D texture sampled by normalized age)
uniform sampler1D uColorOverLifetimeTexture;
uniform bool uColorOverLifetimeEnabled;

// Force over lifetime
uniform vec3 uForceOverLifetime;
uniform bool uForceOverLifetimeEnabled;

// Rotation over lifetime
uniform float uRotationOverLifetime;
uniform bool uRotationOverLifetimeEnabled;

// Velocity over lifetime
uniform vec3 uVelocityOverLifetime;
uniform bool uVelocityOverLifetimeEnabled;

// Noise parameters
uniform float uNoiseStrength;
uniform float uNoiseFrequency;
uniform float uNoiseScrollSpeed;
uniform float uTime;
uniform bool uNoiseEnabled;

// ============================================================================
// Utility Functions
// ============================================================================

// Simple 3D noise function
vec3 hash3(vec3 p) {
    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
             dot(p, vec3(269.5, 183.3, 246.1)),
             dot(p, vec3(113.5, 271.9, 124.6)));
    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float noise3D(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    vec3 u = f * f * (3.0 - 2.0 * f);

    return mix(mix(mix(dot(hash3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0)),
                       dot(hash3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0)), u.x),
                   mix(dot(hash3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0)),
                       dot(hash3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0)), u.x), u.y),
               mix(mix(dot(hash3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0)),
                       dot(hash3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0)), u.x),
                   mix(dot(hash3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0)),
                       dot(hash3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z);
}

vec3 curlNoise(vec3 p) {
    const float e = 0.1;
    float n1, n2, a, b;
    vec3 curl;

    n1 = noise3D(vec3(p.x, p.y + e, p.z));
    n2 = noise3D(vec3(p.x, p.y - e, p.z));
    a = (n1 - n2) / (2.0 * e);

    n1 = noise3D(vec3(p.x, p.y, p.z + e));
    n2 = noise3D(vec3(p.x, p.y, p.z - e));
    b = (n1 - n2) / (2.0 * e);

    curl.x = a - b;

    n1 = noise3D(vec3(p.x, p.y, p.z + e));
    n2 = noise3D(vec3(p.x, p.y, p.z - e));
    a = (n1 - n2) / (2.0 * e);

    n1 = noise3D(vec3(p.x + e, p.y, p.z));
    n2 = noise3D(vec3(p.x - e, p.y, p.z));
    b = (n1 - n2) / (2.0 * e);

    curl.y = a - b;

    n1 = noise3D(vec3(p.x + e, p.y, p.z));
    n2 = noise3D(vec3(p.x - e, p.y, p.z));
    a = (n1 - n2) / (2.0 * e);

    n1 = noise3D(vec3(p.x, p.y + e, p.z));
    n2 = noise3D(vec3(p.x, p.y - e, p.z));
    b = (n1 - n2) / (2.0 * e);

    curl.z = a - b;

    return curl;
}

// ============================================================================
// Main Compute Shader
// ============================================================================

void main() {
    uint id = gl_GlobalInvocationID.x;

    // Bounds check
    if (id >= particles.length()) return;

    // Skip dead particles
    if (particles[id].alive == 0) return;

    float dt = uDeltaTime * uSimulationSpeed;

    // Update age
    particles[id].age += dt;

    // Check if particle should die
    if (particles[id].age >= particles[id].lifetime) {
        particles[id].alive = 0;
        return;
    }

    // Normalized lifetime (0-1)
    float normalizedAge = particles[id].age / particles[id].lifetime;

    // ========================================================================
    // Apply Forces
    // ========================================================================

    vec3 acceleration = vec3(0.0);

    // Gravity
    acceleration += uGravity;

    // Force over lifetime
    if (uForceOverLifetimeEnabled) {
        acceleration += uForceOverLifetime;
    }

    // Drag (velocity damping)
    vec3 drag = -particles[id].velocity * uDrag;
    acceleration += drag;

    // ========================================================================
    // Noise
    // ========================================================================

    if (uNoiseEnabled) {
        vec3 noisePosition = particles[id].position * uNoiseFrequency + vec3(uTime * uNoiseScrollSpeed);
        vec3 noiseForce = curlNoise(noisePosition) * uNoiseStrength;
        acceleration += noiseForce;
    }

    // ========================================================================
    // Velocity Updates
    // ========================================================================

    // Apply acceleration
    particles[id].velocity += acceleration * dt;

    // Velocity over lifetime (additive)
    if (uVelocityOverLifetimeEnabled) {
        particles[id].velocity += uVelocityOverLifetime * dt;
    }

    // Update position
    particles[id].position += particles[id].velocity * dt;

    // ========================================================================
    // Size Over Lifetime
    // ========================================================================

    if (uSizeOverLifetimeEnabled) {
        float sizeMultiplier = texture(uSizeOverLifetimeCurve, normalizedAge).r;
        particles[id].size = particles[id].startSize * sizeMultiplier;
    }

    // ========================================================================
    // Color Over Lifetime
    // ========================================================================

    if (uColorOverLifetimeEnabled) {
        particles[id].color = texture(uColorOverLifetimeTexture, normalizedAge);
    }

    // ========================================================================
    // Rotation Over Lifetime
    // ========================================================================

    if (uRotationOverLifetimeEnabled) {
        particles[id].rotation.z += uRotationOverLifetime * dt;
    } else {
        // Use initial rotation speed
        particles[id].rotation += vec3(0, 0, particles[id].rotationSpeed) * dt;
    }
}
